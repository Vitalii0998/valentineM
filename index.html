<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Heart Physics</title>
  <style>
    html,body{
      margin:0;
      height:100%;
      background:radial-gradient(circle at 50% 40%, #1b2040 0%, #0d1025 70%);
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      font-family:system-ui;
    }
    #stage{ width:98vmin; height:98vmin; }
    canvas{ width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="stage"></div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
    const {Engine,Render,Runner,Bodies,Composite,Body,Events} = Matter;

    const stage = document.getElementById("stage");
    const engine = Engine.create();
    engine.positionIterations = 10;
    engine.velocityIterations = 10;

    const w = stage.clientWidth;
    const h = stage.clientHeight;

    const render = Render.create({
      element: stage,
      engine,
      options: {
        width: w,
        height: h,
        wireframes: false,
        background: "transparent"
      }
    });

    Render.run(render);
    Runner.run(Runner.create(), engine);

    // ---------------- HEART SHAPE ----------------

    function heartPoints(cx, cy, s, n=240){
      const pts=[];
      for(let i=0;i<n;i++){
        const t=(i/n)*Math.PI*2;
        const x=16*Math.pow(Math.sin(t),3);
        const y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
        pts.push({x: cx + x*s, y: cy - y*s});
      }
      return pts;
    }

    const centerX = w/2;
    const centerY = h/2;
    const scale = Math.min(w,h)*0.03;
    const pts = heartPoints(centerX, centerY, scale);

    function pointInsideHeart(x,y){
      const dx=(x-centerX)/scale;
      const dy=(centerY-y)/scale;
      return Math.pow(dx*dx+dy*dy-1,3) - dx*dx*dy*dy*dy <= 0;
    }

    // walls category
    const WALL_CAT = 0x0001;
    const HEART_CAT = 0x0002;

    // Heart walls
    for(let i=0;i<pts.length;i++){
      const a=pts[i];
      const b=pts[(i+1)%pts.length];
      const dx=b.x-a.x;
      const dy=b.y-a.y;
      const len=Math.hypot(dx,dy);
      const angle=Math.atan2(dy,dx);

      const wall = Bodies.rectangle(
        (a.x+b.x)/2,
        (a.y+b.y)/2,
        len+26,
        26,
        {
          isStatic:true,
          collisionFilter:{ category: WALL_CAT },
          render:{ visible:false }
        }
      );
      Body.setAngle(wall, angle);
      Composite.add(engine.world, wall);
    }

    // ---------------- PARTICLES ----------------

    const hearts=[];
    let textMode=false;
    let textPoints=[];
    let lastShake=0;

    function randomInside(){
      let x,y;
      do{
        x = centerX + (Math.random()-0.5)*scale*18;
        y = centerY + (Math.random()-0.5)*scale*18;
      }while(!pointInsideHeart(x,y));
      return {x,y};
    }

    function spawnOne(){
      const r = 6 + Math.random()*3; // size
      const pos = randomInside();

      const body = Bodies.circle(pos.x, pos.y, r, {
        restitution: 0.05,
        friction: 0.15,
        frictionAir: 0.001,
        density: 0.003,
        collisionFilter: { category: HEART_CAT, mask: WALL_CAT | HEART_CAT },
        render: { visible:false }
      });

      Composite.add(engine.world, body);
      hearts.push({body,r});

      // Activate text earlier
      if(hearts.length >= 180 && !textMode){
        textMode = true;
        generateTextPoints();
        // freeze chaos immediately
        for(const hrt of hearts){
          Body.setVelocity(hrt.body,{x:0,y:0});
          Body.setAngularVelocity(hrt.body,0);
        }
      }

      // cap
      if(hearts.length > 600){
        Composite.remove(engine.world, hearts.shift().body);
      }
    }

    function spawnBurst(n=20){
      for(let i=0;i<n;i++) spawnOne();
    }

    // ---------------- TEXT POINTS (V / M / Valentine) ----------------

    function generateTextPoints(){
      const off=document.createElement("canvas");
      off.width=w; off.height=h;
      const ctx=off.getContext("2d");

      ctx.clearRect(0,0,w,h);
      ctx.fillStyle="white";
      ctx.textAlign="center";
      ctx.textBaseline="middle";

      ctx.font="800 96px Arial";
      ctx.fillText("V", w/2 - 140, h/2 - 30);
      ctx.fillText("M", w/2 + 140, h/2 - 30);

      ctx.font="800 64px Arial";
      ctx.fillText("Valentine", w/2, h/2 + 140);

      const data=ctx.getImageData(0,0,w,h).data;

      textPoints=[];
      for(let y=0;y<h;y+=6){
        for(let x=0;x<w;x+=6){
          const i=(y*w+x)*4;
          if(data[i+3] > 150 && pointInsideHeart(x,y)){
            textPoints.push({x,y});
          }
        }
      }

      // shuffle for nicer distribution
      for (let i = textPoints.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [textPoints[i], textPoints[j]] = [textPoints[j], textPoints[i]];
      }
    }

    // ---------------- RENDER ----------------

    Events.on(render,"afterRender",()=>{
      const ctx=render.context;

      // heart outline
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(const p of pts) ctx.lineTo(p.x,p.y);
      ctx.closePath();

      const grad=ctx.createLinearGradient(0,0,w,h);
      grad.addColorStop(0,"#ff6aa2");
      grad.addColorStop(1,"#ff003c");
      ctx.strokeStyle=grad;
      ctx.lineWidth=6;
      ctx.shadowBlur=25;
      ctx.shadowColor="#ff3d7a";
      ctx.stroke();
      ctx.shadowBlur=0;

      // particles
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      for(const hrt of hearts){
        const p=hrt.body.position;
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate(hrt.body.angle);
        ctx.font = (hrt.r*2) + "px system-ui, Apple Color Emoji, Segoe UI Emoji";
        ctx.fillText("â¤ï¸",0,0);
        ctx.restore();
      }
    });

    // ---------------- MOTION ----------------

function motion(e){

  const now = Date.now();

  const g = e.accelerationIncludingGravity;
  if(!g) return;

  const mag = Math.sqrt(
    (g.x||0)**2 +
    (g.y||0)**2 +
    (g.z||0)**2
  );

  // ðŸ”¥ Ð½Ð¸Ð¶Ñ‡Ð¸Ð¹ Ð¿Ð¾Ñ€Ñ–Ð³
  if(mag > 16 && now-lastShake > 250){
    lastShake = now;
    spawnBurst(20);
  }

  if(!textMode){
    engine.gravity.x = -(g.x || 0) / 10;
    engine.gravity.y =  (g.y || 0) / 10;
  }
}


      // NORMAL MODE
      const a = e.acceleration || e.accelerationIncludingGravity;
      if(a){
        const mag = Math.sqrt((a.x||0)**2+(a.y||0)**2+(a.z||0)**2);
        if(mag > 14 && now-lastShake > 200){
          lastShake = now;
          spawnBurst(20);
        }
      }

      const g = e.accelerationIncludingGravity;
      if(g){
        engine.gravity.x = -(g.x || 0) / 10;
        engine.gravity.y =  (g.y || 0) / 10;
      }
    }

window.addEventListener("pointerdown", ()=>{
  spawnBurst(20); // Ñ‰Ð¾Ð± Ñ‚Ð¸ Ð¾Ð´Ñ€Ð°Ð·Ñƒ Ð±Ð°Ñ‡Ð¸Ð² Ñ‰Ð¾ Ð²ÑÐµ Ð¿Ñ€Ð°Ñ†ÑŽÑ”
  window.addEventListener("devicemotion", motion, {passive:true});
}, {once:true});

    // Desktop test
    window.addEventListener("keydown", e=>{
      if(e.code === "Space") spawnBurst(20);
    });
  </script>
</body>
</html>

