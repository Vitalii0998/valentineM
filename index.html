<!doctype html>
<html lang="uk">
<head>
<link rel="apple-touch-icon" href="./apple-touch-icon.png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üíó</title>

<style>
html,body{
  margin:0;
  height:100%;
  background:radial-gradient(circle at 50% 40%, #1b2040 0%, #0d1025 70%);
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
}
#stage{
  width:98vmin;
  height:98vmin;
}
canvas{width:100%;height:100%}
</style>
</head>
<body>
<div id="stage"></div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
const {Engine,Render,Runner,Bodies,Composite,Body,Events} = Matter;

const stage=document.getElementById("stage");
const engine=Engine.create();
engine.positionIterations=10;
engine.velocityIterations=10;
engine.enableSleeping=false;

const w=stage.clientWidth;
const h=stage.clientHeight;
const DPR=Math.min(window.devicePixelRatio||1,3);

const render=Render.create({
  element:stage,
  engine,
  options:{
    width:w,
    height:h,
    wireframes:false,
    background:"transparent",
    pixelRatio:DPR
  }
});

Render.run(render);
Runner.run(Runner.create(),engine);

// ---------------- HEART SHAPE ----------------

function heartPoints(cx,cy,scale,n=220){
  const pts=[];
  for(let i=0;i<n;i++){
    const t=(i/n)*Math.PI*2;
    const x=16*Math.pow(Math.sin(t),3);
    const y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
    pts.push({x:cx+x*scale,y:cy-y*scale});
  }
  return pts;
}

const centerX=w/2;
const centerY=h/2;
const scale=Math.min(w,h)*0.03;

function pointInsideHeart(x,y){
  // –§–æ—Ä–º—É–ª–∞ —Å–µ—Ä—Ü—è –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω–∞ –≤ –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ ~[-1..1],
  // –∞ –Ω–∞—à –∫–æ–Ω—Ç—É—Ä –±—É–¥—É—î—Ç—å—Å—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–Ω–æ –∑ –º–Ω–æ–∂–Ω–∏–∫–æ–º 16*scale.
  // –¢–æ–º—É –ø–µ—Ä–µ–≤—ñ—Ä–∫—É "–≤—Å–µ—Ä–µ–¥–∏–Ω—ñ" —Ç—Ä–µ–±–∞ –º–∞—Å—à—Ç–∞–±—É–≤–∞—Ç–∏ —Ç–∞–∫ —Å–∞–º–æ,
  // —ñ–Ω–∞–∫—à–µ –º–∞–π–∂–µ –≤—Å—ñ —Ç–æ—á–∫–∏ –≤–≤–∞–∂–∞–ª–∏—Å—å "–∑–æ–≤–Ω—ñ" —Ç–∞ –∑–ª–∏–ø–∞–ª–∏—Å—å —É —Ü–µ–Ω—Ç—Ä—ñ.
  const norm=16*scale;
  const dx=(x-centerX)/norm;
  const dy=(centerY-y)/norm;
  return Math.pow(dx*dx+dy*dy-1,3)-dx*dx*dy*dy*dy <= 0;
}

const pts=heartPoints(centerX,centerY,scale);

// —Ñ—ñ–∑–∏—á–Ω—ñ —Å—Ç—ñ–Ω–∫–∏
for(let i=0;i<pts.length;i++){
  const a=pts[i];
  const b=pts[(i+1)%pts.length];
  const dx=b.x-a.x;
  const dy=b.y-a.y;
  const len=Math.hypot(dx,dy);
  const angle=Math.atan2(dy,dx);

  const wall=Bodies.rectangle(
    (a.x+b.x)/2,
    (a.y+b.y)/2,
    len+25,
    25,
    {
      isStatic:true,
      friction:0,
      frictionStatic:0,
      restitution:0.2,
      collisionFilter:{ category:0x0001 }
    }
  );

  Body.setAngle(wall,angle);
  Composite.add(engine.world,wall);
}

// ---------------- PARTICLES ----------------

const hearts=[];
let textMode=false;
let textPoints=[];
let targets=[];
let resetMode="idle"; // idle | gather | explode
let resetGatherStartedAt=0;
let resetGatherSettledAt=0;
let resetExplodeStartedAt=0;
let textModeStartedAt=0;
let textForceSnapDone=false;

const EXPLODE_MAX_LIFETIME_MS=3000;
const EXPLODE_FAST_CLEANUP_Y=h*0.88;
const TEXT_MODE_MIN_HOLD_MS=900;
const TEXT_FORCE_SNAP_MS=1400;

const IS_IOS=/iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==="MacIntel" && navigator.maxTouchPoints>1);
const IS_IPAD=/iPad/.test(navigator.userAgent) || (navigator.platform==="MacIntel" && navigator.maxTouchPoints>1);
const SHAKE_THRESHOLD=IS_IOS?9.5:12;

const REFERENCE_AREA=390*844;
const viewportArea=Math.max(1,w*h);
const areaScale=Math.min(2.35,Math.max(1,Math.sqrt(viewportArea/REFERENCE_AREA)));

const NORMAL_HEART_RADIUS=5.1*areaScale;
const TEXT_MODE_TRIGGER=2100;
const MAX_HEARTS=8500;
const SHAKE_SPAWN_BURST=35;
const KEYBOARD_SPAWN_BURST=18;

const heartSpriteCache=new Map();
function getHeartSprite(size){
  const key=Math.max(3,Math.round(size));
  if(heartSpriteCache.has(key)) return heartSpriteCache.get(key);
  const c=document.createElement("canvas");
  const pad=4;
  c.width=key+pad*2;
  c.height=key+pad*2;
  const cctx=c.getContext("2d");
  const cx=c.width/2;
  const cy=c.height/2+0.2;
  const s=key/18;

  cctx.beginPath();
  cctx.moveTo(cx,cy+7*s);
  cctx.bezierCurveTo(cx-8*s,cy+1*s,cx-8*s,cy-4*s,cx,cy-1*s);
  cctx.bezierCurveTo(cx+8*s,cy-4*s,cx+8*s,cy+1*s,cx,cy+7*s);
  cctx.closePath();

  cctx.fillStyle="#ff295f";
  cctx.fill();
  cctx.lineWidth=Math.max(0.8,1.2*s);
  cctx.strokeStyle="rgba(255,255,255,0.45)";
  cctx.stroke();

  heartSpriteCache.set(key,c);
  return c;
}

function pointInsideHeartWithMargin(x,y,margin=0){
  if(!pointInsideHeart(x,y)) return false;
  if(margin<=0) return true;

  // –©–æ–± —Å–µ—Ä–¥–µ—á–∫–æ –Ω–µ –≤–∏–ª—ñ–∑–∞–ª–æ –∑–∞ –∫–æ–Ω—Ç—É—Ä –ø—Ä–∏ —Å–ø–∞–≤–Ω—ñ, –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ
  // –Ω–µ —Ç—ñ–ª—å–∫–∏ —Ü–µ–Ω—Ç—Ä, –∞ –π —Ç–æ—á–∫–∏ –Ω–∞–≤–∫–æ–ª–æ –Ω—å–æ–≥–æ –Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—ñ margin.
  const m=margin;
  return (
    pointInsideHeart(x-m,y) &&
    pointInsideHeart(x+m,y) &&
    pointInsideHeart(x,y-m) &&
    pointInsideHeart(x,y+m) &&
    pointInsideHeart(x-m*0.82,y-m*0.82) &&
    pointInsideHeart(x+m*0.82,y-m*0.82) &&
    pointInsideHeart(x-m*0.82,y+m*0.82) &&
    pointInsideHeart(x+m*0.82,y+m*0.82) &&
    pointInsideHeart(x-m*0.95,y) &&
    pointInsideHeart(x+m*0.95,y) &&
    pointInsideHeart(x,y-m*0.95) &&
    pointInsideHeart(x,y+m*0.95) &&
    pointInsideHeart(x-m*0.45,y) &&
    pointInsideHeart(x+m*0.45,y) &&
    pointInsideHeart(x,y-m*0.45) &&
    pointInsideHeart(x,y+m*0.45)
  );
}

function randomInside(margin=0){
  // –¢—Ä–æ—Ö–∏ –≤—É–∂—á–∏–π –ø–µ—Ä–≤–∏–Ω–Ω–∏–π –±–æ–∫—Å + –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ margin –¥–∞—î —Å—Ç–∞–±—ñ–ª—å–Ω–æ
  // —Å–ø–∞–≤–Ω –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ —Å–µ—Ä—Ü—è –±–µ–∑ –≤–∏—Ö–æ–¥—É –∑–∞ –∫–æ–Ω—Ç—É—Ä.
  const spread=12.2;
  const maxAttempts=220;

  for(let i=0;i<maxAttempts;i++){
    const x=centerX+(Math.random()-0.5)*scale*spread;
    const y=centerY+(Math.random()-0.5)*scale*spread;
    if(pointInsideHeartWithMargin(x,y,margin)) return {x,y};
  }

  // fallback: —è–∫—â–æ –≤–∏–ø–∞–¥–∫–æ–≤–∏–π —Å–µ–º–ø–ª—ñ–Ω–≥ —Ä—ñ–¥–∫–æ –Ω–µ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å –ø–æ–∑–∏—Ü—ñ—é,
  // –æ–±–∏—Ä–∞—î–º–æ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –±–µ–∑–ø–µ—á–Ω—É —Ç–æ—á–∫—É –±–ª–∏–∂—á–µ –¥–æ —Ü–µ–Ω—Ç—Ä—É.
  return {x:centerX,y:centerY+scale*0.8};
}

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=(Math.random()*(i+1))|0;
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}

function moveBodyToward(body,tx,ty,gain,maxStep,snapDist=0.9){
  const px=body.position.x;
  const py=body.position.y;
  const dx=tx-px;
  const dy=ty-py;
  const dist=Math.hypot(dx,dy);
  if(dist<0.0001) return {x:px,y:py,dist:0};

  if(dist<=snapDist){
    Body.setPosition(body,{x:tx,y:ty});
    return {x:tx,y:ty,dist:0};
  }

  const step=Math.min(maxStep,dist*gain);
  const nx=px+(dx/dist)*step;
  const ny=py+(dy/dist)*step;
  Body.setPosition(body,{x:nx,y:ny});
  return {x:nx,y:ny,dist};
}

function enterTextMode(){
  if(resetMode!=="idle") return;
  textMode=true;
  textModeStartedAt=performance.now();
  textForceSnapDone=false;
  generateTextPoints();

  // –≤–∏–º–∏–∫–∞—î–º–æ –∫–æ–ª—ñ–∑—ñ—ó —ñ –≥—Ä–∞–≤—ñ—Ç–∞—Ü—ñ—é –¥–ª—è —Å—Ç–∞–±—ñ–ª—å–Ω–æ–≥–æ —Ñ–æ—Ä–º—É–≤–∞–Ω–Ω—è —Ç–µ–∫—Å—Ç—É
  engine.gravity.x=0;
  engine.gravity.y=0;

  for(const h of hearts){
    Body.setStatic(h.body,false);

    // –Ω–µ –∫–æ–ª–∞–π–¥–∏—Ç—å—Å—è –∑ —ñ–Ω—à–∏–º–∏ —á–∞—Å—Ç–∏–Ω–∫–∞–º–∏ —ñ –≤–∑–∞–≥–∞–ª—ñ –Ω—ñ –∑ —á–∏–º (–≤–∫–ª—é—á–Ω–æ –∑—ñ —Å—Ç—ñ–Ω–∫–∞–º–∏)
    h.body.collisionFilter.group = -1;
    h.body.collisionFilter.mask = 0;

    Body.setVelocity(h.body,{x:0,y:0});
    Body.setAngularVelocity(h.body,0);

    h.targetDrawScale=0.22;
    h.textLocked=false;
  }
}

function startResetSequence(){
  if(!textMode || resetMode!=="idle") return;

  resetMode="gather";
  resetGatherStartedAt=performance.now();
  resetGatherSettledAt=0;
  textMode=false;
  textForceSnapDone=false;
  targets.length=0;

  engine.gravity.x=0;
  engine.gravity.y=0;

  for(const h of hearts){
    Body.setStatic(h.body,false);
    h.body.collisionFilter.group=-1;
    h.body.collisionFilter.mask=0;
    Body.setVelocity(h.body,{x:0,y:0});
    Body.setAngularVelocity(h.body,0);
    h.targetDrawScale=0.26;
    h.textLocked=false;
  }
}

function triggerExplosion(){
  resetMode="explode";
  resetExplodeStartedAt=performance.now();

  engine.gravity.x=0;
  engine.gravity.y=1.0;

  for(const h of hearts){
    const p=h.body.position;

    // –†–æ–∑–∫–∏–¥–∞—î–º–æ –Ω–µ –ª–∏—à–µ —Ä–∞–¥—ñ–∞–ª—å–Ω–æ –≤—ñ–¥ —Ü–µ–Ω—Ç—Ä—É, –∞ –ø–æ –≤—Å—ñ–π –ø–ª–æ—â—ñ —Å–µ—Ä—Ü—è:
    // –±–µ—Ä–µ–º–æ –≤–∏–ø–∞–¥–∫–æ–≤—É —Ç–æ—á–∫—É –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ –∫–æ–Ω—Ç—É—Ä—É —ñ —à—Ç–æ–≤—Ö–∞—î–º–æ —á–∞—Å—Ç–∏–Ω–∫—É –≤ —ó—ó –±—ñ–∫.
    const target=randomInside();
    const tdx=target.x-p.x;
    const tdy=target.y-p.y;
    const tlen=Math.hypot(tdx,tdy)||1;

    const cdx=p.x-centerX;
    const cdy=p.y-centerY;
    const clen=Math.hypot(cdx,cdy)||1;

    // –ú—ñ–∫—Å—É—î–º–æ –Ω–∞–ø—Ä—è–º–æ–∫ –¥–æ –≤–∏–ø–∞–¥–∫–æ–≤–æ—ó —Ç–æ—á–∫–∏ + —Ç—Ä–æ—Ö–∏ —Ä–∞–¥—ñ–∞–ª—å–Ω–æ–≥–æ —Ä–æ–∑–ª—å–æ—Ç—É,
    // —â–æ–± –∑–∞–ø–æ–≤–Ω—é–≤–∞–≤—Å—è –≤–µ—Å—å –∫–æ–Ω—Ç—É—Ä —Å–µ—Ä—Ü—è, –∞ –Ω–µ –∫—ñ–ª—å–∫–∞ –≤—É–∑—å–∫–∏—Ö –ø—Ä–æ–º–µ–Ω—ñ–≤.
    let ux=(tdx/tlen)*0.72 + (cdx/clen)*0.28;
    let uy=(tdy/tlen)*0.72 + (cdy/clen)*0.28;
    const ulen=Math.hypot(ux,uy)||1;
    ux/=ulen;
    uy/=ulen;

    const speed=4.4+Math.random()*2.4;
    const jitter=(Math.random()-0.5)*0.8;

    Body.setStatic(h.body,false);
    // –ü—ñ–¥ —á–∞—Å –≤–∏–±—É—Ö—É –≤–∏–º–∏–∫–∞—î–º–æ –∫–æ–ª—ñ–∑—ñ—ó —Å–µ—Ä—Ü–µ-—Å–µ—Ä—Ü–µ (–º–µ–Ω—à–µ –ª–∞–≥—ñ–≤ –Ω–∞ –º–æ–±—ñ–ª—å–Ω–∏—Ö),
    // –∞–ª–µ –ª–∏—à–∞—î–º–æ –≤–∑–∞—î–º–æ–¥—ñ—é –∑—ñ —Å—Ç—ñ–Ω–∫–∞–º–∏ –∫–æ–Ω—Ç—É—Ä—É —á–µ—Ä–µ–∑ mask/category.
    h.body.collisionFilter.group=-2;
    h.body.collisionFilter.mask=0x0001;
    Body.setVelocity(h.body,{x:ux*speed + jitter,y:uy*speed*0.95 - 0.35});
    Body.setAngularVelocity(h.body,(Math.random()-0.5)*0.45);
    h.targetDrawScale=1.5;
    h.textLocked=false;
  }
}

function cleanupExplodedHearts(){
  const elapsed=performance.now()-resetExplodeStartedAt;

  for(let i=hearts.length-1;i>=0;i--){
    const item=hearts[i];
    const hb=item.body;
    const p=hb.position;

    if(elapsed>1100){
      item.targetDrawScale=0.13;
    }

    const shouldRemove =
      (elapsed>EXPLODE_MAX_LIFETIME_MS && p.y>EXPLODE_FAST_CLEANUP_Y) ||
      (p.y>EXPLODE_FAST_CLEANUP_Y && hb.velocity.y>0.55) ||
      p.y>h+40 ||
      p.x<-50 ||
      p.x>w+50;

    if(shouldRemove){
      Composite.remove(engine.world,hb);
      hearts.splice(i,1);
    }
  }

  if(hearts.length===0){
    resetMode="idle";
    textMode=false;
    textPoints=[];
    targets=[];
    engine.gravity.x=0;
    engine.gravity.y=0;
  }
}

function spawn(){
  if(textMode) return; // –≤–∞–∂–ª–∏–≤–æ: –Ω–µ –¥–æ–¥–∞—î–º–æ –Ω–æ–≤—ñ —á–∞—Å—Ç–∏–Ω–∫–∏ –≤ —Ä–µ–∂–∏–º—ñ —Ç–µ–∫—Å—Ç—É

  const r = NORMAL_HEART_RADIUS;
  const spawnMargin=Math.max(r*4.6,19.5);
  const pos = randomInside(spawnMargin);
  if(!pointInsideHeartWithMargin(pos.x,pos.y,spawnMargin*1.08)){
    pos.x=centerX;
    pos.y=centerY+scale*0.8;
  }

  const body = Bodies.circle(pos.x,pos.y,r,{
    restitution:0.05,
    friction:0.03,
    frictionStatic:0,
    frictionAir:0.0006,
    density:0.003,
    render:{visible:false}
  });

  Composite.add(engine.world,body);
  hearts.push({body,r,drawScale:1,targetDrawScale:1,textLocked:false});

  if(hearts.length>TEXT_MODE_TRIGGER && !textMode){
    enterTextMode();
  }

  if(hearts.length>MAX_HEARTS){
    Composite.remove(engine.world,hearts.shift().body);
  }
}

// ---------------- TEXT ----------------

function generateTextPoints(){
  const off=document.createElement("canvas");
  off.width=w;
  off.height=h;
  const ctx=off.getContext("2d");

  const step=2;

  function collectTextPoints(text,font,x,y){
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle="white";
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.font=font;
    ctx.fillText(text,x,y);

    const data=ctx.getImageData(0,0,w,h).data;
    const points=[];
    for(let py=0;py<h;py+=step){
      for(let px=0;px<w;px+=step){
        const i=(py*w+px)*4;
        if(data[i+3]>150 && pointInsideHeart(px,py)){
          points.push({x:px,y:py});
        }
      }
    }
    return shuffle(points);
  }

  function sampleLine(x1,y1,x2,y2,n){
    const pts=[];
    for(let i=0;i<n;i++){
      const t=n===1?0:i/(n-1);
      const x=x1+(x2-x1)*t;
      const y=y1+(y2-y1)*t;
      if(pointInsideHeart(x,y)) pts.push({x,y});
    }
    return pts;
  }

  function buildVPoints(cx,cy,size){
    return [
      ...sampleLine(cx-size,cy-size*0.7,cx,cy+size,50),
      ...sampleLine(cx+size,cy-size*0.7,cx,cy+size,50)
    ];
  }

  function buildMPoints(cx,cy,size){
    return [
      ...sampleLine(cx-size,cy+size,cx-size,cy-size,42),
      ...sampleLine(cx-size,cy-size,cx,cy+size*0.1,34),
      ...sampleLine(cx,cy+size*0.1,cx+size,cy-size,34),
      ...sampleLine(cx+size,cy-size,cx+size,cy+size,42)
    ];
  }

  function ensurePool(pool,fallbackFactory){
    const dedup=[];
    const used=new Set();
    for(const p of pool){
      const k=((p.x|0)<<16)|(p.y|0);
      if(!used.has(k)){
        used.add(k);
        dedup.push(p);
      }
    }
    if(dedup.length>=24) return dedup;
    return fallbackFactory();
  }

  function assignFromPool(pool,count,jitterMax=4,drawScale=0.18){
    const out=[];
    if(pool.length===0){
      for(let i=0;i<count;i++) out.push({...randomInside(),drawScale});
      return out;
    }

    // –Ø–∫—â–æ —Å–µ—Ä–¥–µ—á–æ–∫ –º–µ–Ω—à–µ –∑–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ç–æ—á–æ–∫, –±–µ—Ä–µ–º–æ —Ç–æ—á–∫–∏ —Ä—ñ–≤–Ω–æ–º—ñ—Ä–Ω–æ –ø–æ –≤—Å—å–æ–º—É –∫–æ–Ω—Ç—É—Ä—É,
    // —â–æ–± –Ω–µ –±—É–ª–æ –≤–∏–ø–∞–¥–∫–æ–≤–∏—Ö "–¥—ñ—Ä" —É –ª—ñ—Ç–µ—Ä–∞—Ö —á–µ—Ä–µ–∑ –ª–æ–∫–∞–ª—å–Ω—É –Ω–µ–¥–æ–∑–∞–ø–æ–≤–Ω–µ–Ω—ñ—Å—Ç—å.
    if(count<=pool.length){
      for(let i=0;i<count;i++){
        const idx=Math.floor((i*pool.length)/Math.max(1,count));
        const base=pool[Math.min(pool.length-1,idx)];
        out.push({x:base.x,y:base.y,drawScale});
      }
      return out;
    }

    for(let i=0;i<count;i++){
      const base=pool[i%pool.length];
      const rep=(i/pool.length)|0;
      if(rep===0){
        out.push({x:base.x,y:base.y,drawScale});
        continue;
      }
      const angle=i*0.63+rep*1.17;
      const radius=Math.min(jitterMax,rep*0.45);
      const x=base.x+Math.cos(angle)*radius;
      const y=base.y+Math.sin(angle)*radius;
      out.push(pointInsideHeart(x,y)?{x,y,drawScale}:{x:base.x,y:base.y,drawScale});
    }
    return out;
  }

  // –†–æ–∑–∫–ª–∞–¥–∫–∞: V –ª—ñ–≤–æ—Ä—É—á, M –ø—Ä–∞–≤–æ—Ä—É—á, –∑–Ω–∏–∑—É "valentine's" —ñ –ø—ñ–¥ –Ω–∏–º –ø–æ —Ü–µ–Ω—Ç—Ä—É "day"
  const xL=centerX-scale*4.8;
  const xR=centerX+scale*4.8;
  const yTop=centerY-scale*1.5;
  const yWordTop=centerY+scale*4.2;
  const yWordBottom=yWordTop+scale*2.2;

  const fontVM=`900 ${Math.round(scale*4.2)}px Arial`;
  const fontWordTop=`900 ${Math.round(scale*2.45)}px Arial`;
  const fontWordBottom=`900 ${Math.round(scale*2.45)}px Arial`;

  const vGlyph=collectTextPoints("V",fontVM,xL,yTop);
  const mGlyph=collectTextPoints("M",fontVM,xR,yTop);
  const wordTopGlyph=collectTextPoints("valentine's",fontWordTop,centerX,yWordTop);
  const wordBottomGlyph=collectTextPoints("day",fontWordBottom,centerX,yWordBottom);

  const vPoints=ensurePool(vGlyph,()=>buildVPoints(xL,yTop,scale*1.55));
  const mPoints=ensurePool(mGlyph,()=>buildMPoints(xR,yTop,scale*1.45));
  const wordTopPoints=wordTopGlyph.length>=28
    ? wordTopGlyph
    : sampleLine(centerX-scale*5.2,yWordTop,centerX+scale*5.2,yWordTop,210);
  const wordBottomPoints=wordBottomGlyph.length>=14
    ? wordBottomGlyph
    : sampleLine(centerX-scale*1.8,yWordBottom,centerX+scale*1.8,yWordBottom,90);
  const wordPoints=[...wordTopPoints,...wordBottomPoints];

  textPoints=[...vPoints,...mPoints,...wordPoints];

  targets=[];
  if(textPoints.length===0){
    for(let i=0;i<hearts.length;i++) targets[i]={...randomInside(),drawScale:0.18};
    return;
  }

  // –¢—Ä–æ—Ö–∏ –±—ñ–ª—å—à–µ —Å–µ—Ä–¥–µ—á–æ–∫ —É V/M, –∞–ª–µ –±—ñ–ª—å—à—ñ—Å—Ç—å –ª–∏—à–∞—î—Ç—å—Å—è –Ω–∞ words
  const total=hearts.length;
  const vCount=Math.round(total*0.13);
  const mCount=Math.round(total*0.30);
  const wordCount=total-vCount-mCount;

  targets.push(...assignFromPool(vPoints,vCount,3.1,0.26));
  targets.push(...assignFromPool(mPoints,mCount,3.1,0.26));

  const wordTopCount=Math.round(wordCount*0.70);
  const wordBottomCount=wordCount-wordTopCount;
  targets.push(...assignFromPool(wordTopPoints,wordTopCount,0.14,0.175));
  targets.push(...assignFromPool(wordBottomPoints,wordBottomCount,0.12,0.165));

  shuffle(targets);
}


// ---------------- RENDER ----------------

Events.on(render,"afterRender",()=>{
  const ctx=render.context;

  // –∫–æ–Ω—Ç—É—Ä —Å–µ—Ä—Ü—è
  ctx.beginPath();
  ctx.moveTo(pts[0].x,pts[0].y);
  for(const p of pts) ctx.lineTo(p.x,p.y);
  ctx.closePath();

  const grad=ctx.createLinearGradient(0,0,w,h);
  grad.addColorStop(0,"#ff6aa2");
  grad.addColorStop(1,"#ff003c");

  ctx.strokeStyle=grad;
  ctx.lineWidth=6;
  ctx.shadowBlur=25;
  ctx.shadowColor="#ff3d7a";
  ctx.stroke();
  ctx.shadowBlur=0;

  // —á–∞—Å—Ç–∏–Ω–∫–∏
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  for(const hrt of hearts){
    const p=hrt.body.position;
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(hrt.body.angle);
    hrt.drawScale += (hrt.targetDrawScale-hrt.drawScale)*0.16;
    const glyphSize=Math.max(2.6,hrt.r*2*hrt.drawScale);
    const sprite=getHeartSprite(glyphSize);
    ctx.drawImage(sprite,-sprite.width/2,-sprite.height/2);
    ctx.restore();
  }
});

// ---------------- MOTION ----------------

let lastShake=0;
let motionPermissionState="unknown";
let motionPromptInFlight=false;
let iPadOrientation={beta:0,gamma:0,ts:0};
let iPadOrientationNeutral={beta:0,gamma:0,ready:false};

function getScreenAngle(){
  if(window.screen && window.screen.orientation && typeof window.screen.orientation.angle==="number"){
    return (window.screen.orientation.angle%360+360)%360;
  }
  if(typeof window.orientation==="number") return (window.orientation%360+360)%360;
  return 0;
}
function onDeviceOrientation(e){
  if(e.beta==null || e.gamma==null) return;
  iPadOrientation={beta:e.beta,gamma:e.gamma,ts:performance.now()};
  if(IS_IPAD && !iPadOrientationNeutral.ready){
    iPadOrientationNeutral={beta:e.beta,gamma:e.gamma,ready:true};
  }

  // –î–ª—è iPad –æ–Ω–æ–≤–ª—é—î–º–æ –≥—Ä–∞–≤—ñ—Ç–∞—Ü—ñ—é –æ–¥—Ä–∞–∑—É –Ω–∞ orientation event,
  // —â–æ–± –Ω–µ —á–µ–∫–∞—Ç–∏ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ devicemotion —Ç—ñ–∫—É (–º–µ–Ω—à–∞ –∑–∞—Ç—Ä–∏–º–∫–∞ —Ä–µ–∞–∫—Ü—ñ—ó).
  if(IS_IPAD && !textMode && resetMode==="idle"){
    const mapped=mapGravityFromIpadOrientation();
    if(mapped){
      engine.gravity.x=mapped.x;
      engine.gravity.y=mapped.y;
    }
  }
}

function mapGravityFromIpadOrientation(){
  if(!iPadOrientationNeutral.ready) return null;
  const angle=getScreenAngle();

  let db=iPadOrientation.beta-iPadOrientationNeutral.beta;
  let dg=iPadOrientation.gamma-iPadOrientationNeutral.gamma;
  db=Math.max(-65,Math.min(65,db));
  dg=Math.max(-65,Math.min(65,dg));

  // –Ø–≤–Ω–∏–π screen-space –º–∞–ø—ñ–Ω–≥ –¥–ª—è iPad (–æ–∫—Ä–µ–º–æ –ø–æ –∫—É—Ç—É),
  // —â–æ–± –Ω–∞—Ö–∏–ª –≤–ø—Ä–∞–≤–æ/–≤–ª—ñ–≤–æ –±—É–≤ —Å–∏–º–µ—Ç—Ä–∏—á–Ω–∏–º —É portrait/landscape.
  let sx=dg;
  let sy=db;
  if(angle===90){
    sx=-db;
    sy=-dg;
  }else if(angle===270){
    sx=db;
    sy=dg;
  }else if(angle===180){
    sx=-dg;
    sy=-db;
  }

  let x=sx/26;
  let y=0.56 + sy/82;

  if(Math.abs(x)<0.01) x=0;
  if(Math.abs(y-0.56)<0.01) y=0.56;

  x=Math.max(-0.95,Math.min(0.95,x));
  y=Math.max(0.08,Math.min(1,y));
  return {x,y};
}

function mapGravityFromMotion(g){
  const gx=g.x||0;
  const gy=g.y||0;
  const angle=getScreenAngle();

  // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –æ—Å—ñ —Å–µ–Ω—Å–æ—Ä–∞ —É –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –µ–∫—Ä–∞–Ω–∞, —â–æ–± –ø—Ä–∏ —Ä–æ—Ç–∞—Ü—ñ—ó
  // —Å–µ—Ä–¥–µ—á–∫–∞ –≤—Å–µ –æ–¥–Ω–æ –ø–∞–¥–∞–ª–∏ "–≤–Ω–∏–∑" –≤—ñ–¥–Ω–æ—Å–Ω–æ –ø–æ—Ç–æ—á–Ω–æ—ó –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—ó.
  let sx=gx;
  let sy=gy;
  if(angle===90){
    sx=gy;
    sy=-gx;
  }else if(angle===270){
    sx=-gy;
    sy=gx;
  }else if(angle===180){
    sx=-gx;
    sy=-gy;
  }

  // –î–ª—è iPad –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ deviceorientation —É motion(),
  // –∞ —Ç—É—Ç –ª–∏—à–∞—î—Ç—å—Å—è fallback-–º–∞–ø—ñ–Ω–≥.

  // –ù–∞ iPhone/Android –ª–∏—à–∞—î—Ç—å—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–π sign-map.
  const xSign=IS_IOS?1:-1;
  const ySign=IS_IOS?-1:1;
  const x=(sx*xSign)/10;
  const y=(sy*ySign)/10;
  return {x,y};
}

function showMotionHint(msg){
  let hint=document.getElementById("motionHint");
  if(!hint){
    hint=document.createElement("div");
    hint.id="motionHint";
    hint.style.cssText="position:fixed;left:50%;bottom:18px;transform:translateX(-50%);z-index:9999;padding:10px 14px;border-radius:10px;background:rgba(8,11,28,.82);color:#fff;font:600 13px/1.25 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:min(92vw,460px);text-align:center;box-shadow:0 6px 20px rgba(0,0,0,.3);";
    document.body.appendChild(hint);
  }
  hint.textContent=msg;
}

function renderMotionEnableButton(){
  if(!IS_IOS || window.__motionBound) return;
  if(document.getElementById("motionEnableBtn")) return;
  const btn=document.createElement("button");
  btn.id="motionEnableBtn";
  btn.textContent="Start";
  btn.style.cssText="position:fixed;left:50%;bottom:72px;transform:translateX(-50%);z-index:10000;border:0;border-radius:12px;padding:11px 16px;background:#ff3d7a;color:#fff;font:700 14px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;box-shadow:0 8px 20px rgba(0,0,0,.32);";
  btn.addEventListener("click",async (ev)=>{
    ev.stopPropagation();
    const ok=await ensureMotionPermission();
    if(ok){
      btn.remove();
      const hint=document.getElementById("motionHint");
      if(hint) hint.remove();
    }
  });
  document.body.appendChild(btn);
}

function bindMotionListener(){
  if(window.__motionBound) return;
  window.addEventListener("devicemotion",motion,{passive:true});
  window.addEventListener("deviceorientation",onDeviceOrientation,{passive:true});
  window.__motionBound=true;
}

async function ensureMotionPermission(){
  if(window.__motionBound) return true;
  if(motionPromptInFlight) return false;
  motionPromptInFlight=true;

  try{
    const DME=window.DeviceMotionEvent;
    if(typeof DME!=="undefined" && typeof DME.requestPermission==="function"){
      const motionState=await DME.requestPermission();
      if(motionState!=="granted"){
        motionPermissionState="denied";
        showMotionHint("–ù–∞—Ç–∏—Å–Ω–∏ –∫–Ω–æ–ø–∫—É ¬´Start¬ª, –ø–æ—Ç—ñ–º Allow —É Safari. –Ø–∫—â–æ –≤—ñ–∫–Ω–æ –Ω–µ –∑‚Äô—è–≤–ª—è—î—Ç—å—Å—è ‚Äî –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂ —Å—Ç–æ—Ä—ñ–Ω–∫—É.");
        renderMotionEnableButton();
        return false;
      }

      // Orientation –Ω–∞ —á–∞—Å—Ç–∏–Ω—ñ iOS –º–æ–∂–µ –±—É—Ç–∏ –Ω–µ—Å—Ç–∞–±—ñ–ª—å–Ω–∏–º; –¥–ª—è shake –¥–æ—Å—Ç–∞—Ç–Ω—å–æ motion.
      const DOE=window.DeviceOrientationEvent;
      if(typeof DOE!=="undefined" && typeof DOE.requestPermission==="function"){
        try{ await DOE.requestPermission(); }catch(_err){ /* best-effort */ }
      }
    }

    bindMotionListener();
    motionPermissionState="granted";
    const hint=document.getElementById("motionHint");
    if(hint) hint.remove();
    const btn=document.getElementById("motionEnableBtn");
    if(btn) btn.remove();
    return true;
  }catch(_err){
    motionPermissionState="denied";
    showMotionHint("Safari –∑–∞–±–ª–æ–∫—É–≤–∞–≤ —Å–µ–Ω—Å–æ—Ä–∏. –ù–∞—Ç–∏—Å–Ω–∏ ¬´Start¬ª —ñ –ø—ñ–¥—Ç–≤–µ—Ä–¥—å Allow.");
    renderMotionEnableButton();
    return false;
  }finally{
    motionPromptInFlight=false;
  }
}

function updateTextMode(){
  if(resetMode==="gather"){
    let settled=0;
    for(const h of hearts){
      const moved=moveBodyToward(h.body,centerX,centerY,0.09,4.8,1.4);
      Body.setVelocity(h.body,{x:0,y:0});
      Body.setAngularVelocity(h.body,0);
      h.targetDrawScale=0.22;

      const dx=centerX-moved.x;
      const dy=centerY-moved.y;
      if(dx*dx+dy*dy<24*24) settled++;
    }

    const now=performance.now();
    if(settled>=Math.max(1,Math.floor(hearts.length*0.95))){
      if(resetGatherSettledAt===0) resetGatherSettledAt=now;
    }else{
      resetGatherSettledAt=0;
    }

    const settledLongEnough=resetGatherSettledAt>0 && (now-resetGatherSettledAt)>420;
    if(settledLongEnough || now-resetGatherStartedAt>1300){
      triggerExplosion();
      return;
    }

    // —Å—Ç—Ä–∞—Ö—É—î–º–æ—Å—å –≤—ñ–¥ –∑–∞–≤–∏—Å–∞–Ω–Ω—è —É gather, —è–∫—â–æ –ø—Ä–∏—Å—Ç—Ä—ñ–π –ø—Ä–æ—Å—ñ–¥–∞—î –ø–æ FPS
    if(now-resetGatherStartedAt>2200){
      triggerExplosion();
      return;
    }
    return;
  }

  if(resetMode==="explode"){
    cleanupExplodedHearts();
    return;
  }

  if(!textMode) return;

  let lockedCount=0;

  // –ø–ª–∞–≤–Ω–æ –ø—ñ–¥—Ç—è–≥—É–≤–∞—Ç–∏ –¥–æ —Ü—ñ–ª–µ–π, –±–µ–∑ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ –≤—ñ–¥ devicemotion
  for(let i=0;i<hearts.length;i++){
    const h=hearts[i];
    const t=targets[i];
    if(!t) continue;

    if(h.textLocked){
      // –ù–∞ –º–æ–±—ñ–ª—å–Ω–∏—Ö —ñ–Ω–∫–æ–ª–∏ —î –º—ñ–∫—Ä–æ–¥—Ä–µ–π—Ñ –Ω–∞–≤—ñ—Ç—å –ø—ñ—Å–ª—è settle,
      // —Ç–æ–º—É –∂–æ—Ä—Å—Ç–∫–æ –ø—ñ–Ω–Ω–∏–º–æ –≤–∂–µ –∑–∞—Ñ—ñ–∫—Å–æ–≤–∞–Ω—ñ —á–∞—Å—Ç–∏–Ω–∫–∏ –≤ target.
      Body.setPosition(h.body,{x:t.x,y:t.y});
      Body.setVelocity(h.body,{x:0,y:0});
      Body.setAngularVelocity(h.body,0);
      h.targetDrawScale=t.drawScale ?? 0.18;
      lockedCount++;
      continue;
    }

    const drawScale=t.drawScale ?? 0.18;
    const gain=drawScale<0.1 ? 0.18 : 0.13;
    const maxStep=drawScale<0.1 ? 7.0 : 5.8;
    const snapDist=drawScale<0.1 ? 0.85 : 0.95;

    const moved=moveBodyToward(h.body,t.x,t.y,gain,maxStep,snapDist);
    Body.setVelocity(h.body,{x:0,y:0});
    Body.setAngularVelocity(h.body,0);

    h.targetDrawScale=drawScale;

    const dx=t.x-moved.x;
    const dy=t.y-moved.y;
    const settleDist=drawScale < 0.1 ? 1.7 : 1.5;
    if(dx*dx+dy*dy < settleDist*settleDist){
      Body.setPosition(h.body,{x:t.x,y:t.y});
      Body.setVelocity(h.body,{x:0,y:0});
      Body.setAngularVelocity(h.body,0);
      h.textLocked=true;
      lockedCount++;
    }
  }

  const now=performance.now();
  if(!textForceSnapDone && hearts.length>0 && lockedCount<hearts.length && now-textModeStartedAt>TEXT_FORCE_SNAP_MS){
    for(let i=0;i<hearts.length;i++){
      const h=hearts[i];
      const t=targets[i];
      if(!t) continue;
      Body.setPosition(h.body,{x:t.x,y:t.y});
      Body.setVelocity(h.body,{x:0,y:0});
      Body.setAngularVelocity(h.body,0);
      h.targetDrawScale=t.drawScale ?? 0.18;
      h.textLocked=true;
    }
    textForceSnapDone=true;
  }
}

Events.on(engine,"beforeUpdate",updateTextMode);

function motion(e){
  if(textMode || resetMode!=="idle") return;

  // NORMAL MODE
  const now=Date.now();

  const a=e.acceleration||e.accelerationIncludingGravity;
  if(a){
    const mag=Math.sqrt((a.x||0)**2+(a.y||0)**2+(a.z||0)**2);
    if(mag>SHAKE_THRESHOLD && now-lastShake>140){
      lastShake=now;
      for(let i=0;i<SHAKE_SPAWN_BURST;i++) spawn();
    }
  }

  if(IS_IPAD){
    if(iPadOrientation.ts>0 && (performance.now()-iPadOrientation.ts)<650){
      const mapped=mapGravityFromIpadOrientation();
      if(mapped){
        engine.gravity.x=mapped.x;
        engine.gravity.y=mapped.y;
        return;
      }
    }
    // fallback –¥–ª—è iPad: –±–µ–∑ —Å–µ–Ω—Å–æ—Ä–∞/–¥–æ –∫–∞–ª—ñ–±—Ä—É–≤–∞–Ω–Ω—è –ø—Ä–æ—Å—Ç–æ —Ä—ñ–≤–Ω–æ –≤–Ω–∏–∑
    engine.gravity.x=0;
    engine.gravity.y=0.56;
    return;
  }

  const g=e.accelerationIncludingGravity;
  if(g){
    const mapped=mapGravityFromMotion(g);
    engine.gravity.x=mapped.x;
    engine.gravity.y=mapped.y;
  }
}

window.addEventListener("pointerdown",async ()=>{
  // –ù–∞ iOS prompt —Å—Ç–∞–±—ñ–ª—å–Ω—ñ—à–µ –≤—ñ–¥–∫—Ä–∏–≤–∞—Ç–∏ –∑ —è–≤–Ω–æ—ó –∫–Ω–æ–ø–∫–∏/click.
  if(!IS_IOS){
    const motionReady=await ensureMotionPermission();
    if(!motionReady && !textMode && resetMode==="idle") return;
  }else if(!window.__motionBound){
    renderMotionEnableButton();
  }

  if(resetMode==="gather"){
    triggerExplosion();
    return;
  }
  if(textMode && performance.now()-textModeStartedAt>TEXT_MODE_MIN_HOLD_MS){
    startResetSequence();
  }
});

renderMotionEnableButton();

window.addEventListener("orientationchange",()=>{
  iPadOrientationNeutral.ready=false;
  iPadOrientation.ts=0;
});

window.addEventListener("keydown",e=>{
  if(e.code==="Space"){
    for(let i=0;i<KEYBOARD_SPAWN_BURST;i++) spawn();
  }
});

</script>
</body>
</html>








