<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Heart Physics</title>
  <style>
    html,body{
      margin:0;
      height:100%;
      background:radial-gradient(circle at 50% 40%, #1b2040 0%, #0d1025 70%);
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      font-family:system-ui;
    }
    #stage{ width:98vmin; height:98vmin; }
    canvas{ width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="stage"></div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
    const { Engine, Render, Runner, Bodies, Composite, Body, Events } = Matter;

    const stage = document.getElementById("stage");

    const engine = Engine.create();
    engine.positionIterations = 10;
    engine.velocityIterations = 10;

    const w = stage.clientWidth;
    const h = stage.clientHeight;

    const render = Render.create({
      element: stage,
      engine,
      options: { width: w, height: h, wireframes: false, background: "transparent" }
    });

    Render.run(render);
    Runner.run(Runner.create(), engine);

    // -------- Heart shape --------

    function heartPoints(cx, cy, s, n=240){
      const pts=[];
      for(let i=0;i<n;i++){
        const t=(i/n)*Math.PI*2;
        const x=16*Math.pow(Math.sin(t),3);
        const y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
        pts.push({ x: cx + x*s, y: cy - y*s });
      }
      return pts;
    }

    const centerX = w/2;
    const centerY = h/2;
    const scale = Math.min(w,h)*0.03;
    const outline = heartPoints(centerX, centerY, scale);

    function pointInsideHeart(x,y){
      const dx=(x-centerX)/scale;
      const dy=(centerY-y)/scale;
      return Math.pow(dx*dx+dy*dy-1,3) - dx*dx*dy*dy*dy <= 0;
    }

    // collision categories
    const WALL_CAT  = 0x0001;
    const HEART_CAT = 0x0002;

    // heart walls (static segments)
    for(let i=0;i<outline.length;i++){
      const a=outline[i];
      const b=outline[(i+1)%outline.length];
      const dx=b.x-a.x;
      const dy=b.y-a.y;
      const len=Math.hypot(dx,dy);
      const angle=Math.atan2(dy,dx);

      const wall = Bodies.rectangle(
        (a.x+b.x)/2,
        (a.y+b.y)/2,
        len+26,
        26,
        { isStatic:true, collisionFilter:{ category: WALL_CAT }, render:{ visible:false } }
      );
      Body.setAngle(wall, angle);
      Composite.add(engine.world, wall);
    }

    // -------- Particles --------

    const hearts = [];
    let textMode = false;
    let textPoints = [];

    function randomInside(){
      let x,y;
      do{
        x = centerX + (Math.random()-0.5)*scale*18;
        y = centerY + (Math.random()-0.5)*scale*18;
      } while(!pointInsideHeart(x,y));
      return {x,y};
    }

    function spawnOne(){
      const r = 6 + Math.random()*3;
      const pos = randomInside();

      const body = Bodies.circle(pos.x, pos.y, r, {
        restitution: 0.05,
        friction: 0.15,
        frictionAir: 0.001,
        density: 0.003,
        collisionFilter: { category: HEART_CAT, mask: WALL_CAT | HEART_CAT },
        render: { visible:false }
      });

      Composite.add(engine.world, body);
      hearts.push({ body, r });

      if(!textMode && hearts.length >= 220){
        textMode = true;
        generateTextPoints();

        // зупиняємо інерцію перед складанням
        for(const hrt of hearts){
          Body.setVelocity(hrt.body, {x:0,y:0});
          Body.setAngularVelocity(hrt.body, 0);
        }
      }

      // cap
      if(hearts.length > 650){
        Composite.remove(engine.world, hearts.shift().body);
      }
    }

    function spawnBurst(n=20){
      for(let i=0;i<n;i++) spawnOne();
    }

    // -------- Text points: V / M / Valentine --------

    function generateTextPoints(){
      const off = document.createElement("canvas");
      off.width = w; off.height = h;
      const ctx = off.getContext("2d");

      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = "white";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.font = "800 96px Arial";
      ctx.fillText("V", w/2 - 140, h/2 - 30);
      ctx.fillText("M", w/2 + 140, h/2 - 30);

      ctx.font = "800 64px Arial";
      ctx.fillText("Valentine", w/2, h/2 + 140);

      const data = ctx.getImageData(0,0,w,h).data;

      textPoints = [];
      for(let y=0;y<h;y+=6){
        for(let x=0;x<w;x+=6){
          const i=(y*w+x)*4;
          if(data[i+3] > 150 && pointInsideHeart(x,y)){
            textPoints.push({x,y});
          }
        }
      }

      // shuffle for nicer distribution
      for (let i = textPoints.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [textPoints[i], textPoints[j]] = [textPoints[j], textPoints[i]];
      }
    }

    // -------- Render overlay --------

    Events.on(render, "afterRender", () => {
      const ctx = render.context;

      // heart outline
      ctx.beginPath();
      ctx.moveTo(outline[0].x, outline[0].y);
      for(const p of outline) ctx.lineTo(p.x,p.y);
      ctx.closePath();

      const grad = ctx.createLinearGradient(0,0,w,h);
      grad.addColorStop(0,"#ff6aa2");
      grad.addColorStop(1,"#ff003c");
      ctx.strokeStyle = grad;
      ctx.lineWidth = 6;
      ctx.shadowBlur = 25;
      ctx.shadowColor = "#ff3d7a";
      ctx.stroke();
      ctx.shadowBlur = 0;

      // particles
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for(const hrt of hearts){
        const p = hrt.body.position;
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate(hrt.body.angle);
        ctx.font = (hrt.r*2) + "px system-ui, Apple Color Emoji, Segoe UI Emoji";
        ctx.fillText("❤️", 0, 0);
        ctx.restore();
      }
    });

    // -------- Motion --------

    let lastShake = 0;

    function motion(e){
      const now = Date.now();
      const g = e.accelerationIncludingGravity;
      if(!g) return;

      if(textMode){
        // вимикаємо гравітацію і колізії між сердечками
        engine.gravity.x = 0;
        engine.gravity.y = 0;

        for(const hrt of hearts){
          // collide only with walls while arranging
          hrt.body.collisionFilter.mask = WALL_CAT;
        }

        if(!textPoints.length) return;

        // pull to text points (stable)
        for(let i=0;i<hearts.length;i++){
          const hrt = hearts[i];
          const t = textPoints[i % textPoints.length];

          const dx = t.x - hrt.body.position.x;
          const dy = t.y - hrt.body.position.y;

          Body.setPosition(hrt.body, {
            x: hrt.body.position.x + dx * 0.10,
            y: hrt.body.position.y + dy * 0.10
          });

          if(dx*dx + dy*dy < 16){
            Body.setPosition(hrt.body, t);
          }
        }
        return;
      }

      // NORMAL mode: shake + tilt
      const mag = Math.sqrt((g.x||0)**2 + (g.y||0)**2 + (g.z||0)**2);

      if(mag > 16 && now - lastShake > 250){
        lastShake = now;
        spawnBurst(18);
      }

      engine.gravity.x = -(g.x || 0) / 10;
      engine.gravity.y =  (g.y || 0) / 10;
    }

    // tap to start
    window.addEventListener("pointerdown", () => {
      spawnBurst(20);
      window.addEventListener("devicemotion", motion, { passive:true });
    }, { once:true });

    // desktop test
    window.addEventListener("keydown", (e) => {
      if(e.code === "Space") spawnBurst(20);
    });
  </script>
</body>
</html>
