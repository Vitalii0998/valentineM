<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Heart Physics</title>
<style>
html,body{
  margin:0;
  height:100%;
  background:radial-gradient(circle at 50% 40%, #1b2040 0%, #0d1025 70%);
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
}
#stage{width:98vmin;height:98vmin}
canvas{width:100%;height:100%}
</style>
</head>
<body>
<div id="stage"></div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
const {Engine,Render,Runner,Bodies,Composite,Body,Events,Vertices} = Matter;

const stage = document.getElementById("stage");
const engine = Engine.create();
engine.positionIterations = 10;
engine.velocityIterations = 10;
engine.gravity.scale = 0.001; // стабільніше

const w = stage.clientWidth;
const h = stage.clientHeight;

const render = Render.create({
  element: stage,
  engine,
  options:{
    width:w,
    height:h,
    wireframes:false,
    background:"transparent"
  }
});
Render.run(render);
Runner.run(Runner.create(), engine);

// ---------------- HEART GEOMETRY ----------------

function heartPoints(cx,cy,scale,n=260){
  const pts=[];
  for(let i=0;i<n;i++){
    const t=(i/n)*Math.PI*2;
    const x=16*Math.pow(Math.sin(t),3);
    const y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
    pts.push({x:cx+x*scale,y:cy-y*scale});
  }
  return pts;
}

const centerX = w/2;
const centerY = h/2;
const scale = Math.min(w,h)*0.03;

function pointInsideHeart(x,y){
  const dx=(x-centerX)/scale;
  const dy=(centerY-y)/scale;
  return Math.pow(dx*dx+dy*dy-1,3)-dx*dx*dy*dy*dy <= 0;
}

const outline = heartPoints(centerX, centerY, scale, 320);

// 1 суцільний статичний body
const heartWall = Bodies.fromVertices(
  centerX, centerY,
  [outline.map(p=>({x:p.x,y:p.y}))],
  {
    isStatic:true,
    render:{visible:false},
    friction:0.2,
    restitution:0.1
  },
  true
);

// важливо: інколи fromVertices повертає масив
if (Array.isArray(heartWall)) {
  Composite.add(engine.world, heartWall);
} else {
  Composite.add(engine.world, heartWall);
}

// легка страховка по краях canvas, але тонка і невидима
const pad = 30;
Composite.add(engine.world, [
  Bodies.rectangle(w/2, -pad/2, w+2*pad, pad, {isStatic:true, render:{visible:false}}),
  Bodies.rectangle(w/2, h+pad/2, w+2*pad, pad, {isStatic:true, render:{visible:false}}),
  Bodies.rectangle(-pad/2, h/2, pad, h+2*pad, {isStatic:true, render:{visible:false}}),
  Bodies.rectangle(w+pad/2, h/2, pad, h+2*pad, {isStatic:true, render:{visible:false}}),
]);

// ---------------- PARTICLES ----------------

const hearts=[];
let textMode=false;
let textPoints=[];
let targets=[];

function randomInside(){
  let x,y;
  do{
    x=centerX+(Math.random()-0.5)*scale*18;
    y=centerY+(Math.random()-0.5)*scale*18;
  }while(!pointInsideHeart(x,y));
  return {x,y};
}

function spawn(){
  if(textMode) return;

  const r = 6 + Math.random()*3;
  const pos = randomInside();

  const body = Bodies.circle(pos.x,pos.y,r,{
    restitution:0.2,
    friction:0.05,
    frictionAir:0.01,
    density:0.0025,
    render:{visible:false}
  });

  Composite.add(engine.world,body);
  hearts.push({body,r});

  if(hearts.length>220 && !textMode){
    enterTextMode();
  }

  if(hearts.length>750){
    Composite.remove(engine.world, hearts.shift().body);
  }
}

// анти-тунелювання: м’який ліміт швидкості
const MAX_V = 14;
Events.on(engine,"beforeUpdate",()=>{
  for(const h of hearts){
    const v=h.body.velocity;
    const sp=Math.hypot(v.x,v.y);
    if(sp>MAX_V){
      Body.setVelocity(h.body,{x:v.x*(MAX_V/sp),y:v.y*(MAX_V/sp)});
    }
  }
});

// ---------------- TEXT ----------------

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=(Math.random()*(i+1))|0;
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}

function enterTextMode(){
  textMode=true;
  generateTextPoints();

  engine.gravity.x=0;
  engine.gravity.y=0;

  // прибираємо колізії між частинками, але залишаємо з межами серця
  for(const h of hearts){
    Body.setStatic(h.body,false);
    h.body.collisionFilter.group = -1; // не штовхаються між собою
    h.body.collisionFilter.mask = 0xFFFFFFFF; // колайдяться зі стінками
    Body.setVelocity(h.body,{x:0,y:0});
    Body.setAngularVelocity(h.body,0);
  }
}

function generateTextPoints(){
  const off=document.createElement("canvas");
  off.width=w; off.height=h;
  const ctx=off.getContext("2d");
  ctx.clearRect(0,0,w,h);

  // знайдемо внутрішні межі серця
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for(let y=0;y<h;y+=6){
    for(let x=0;x<w;x+=6){
      if(pointInsideHeart(x,y)){
        if(x<minX)minX=x; if(x>maxX)maxX=x;
        if(y<minY)minY=y; if(y>maxY)maxY=y;
      }
    }
  }

  const padX=(maxX-minX)*0.14;
  const padY=(maxY-minY)*0.14;

  const innerMinX=minX+padX, innerMaxX=maxX-padX;
  const innerMinY=minY+padY, innerMaxY=maxY-padY;
  const innerW=innerMaxX-innerMinX, innerH=innerMaxY-innerMinY;

  const xL=innerMinX+innerW*0.30;
  const xR=innerMinX+innerW*0.70;
  const yTop=innerMinY+innerH*0.38;
  const yBottom=innerMinY+innerH*0.74;

  ctx.fillStyle="white";
  ctx.textAlign="center";
  ctx.textBaseline="middle";

  const big=Math.round(Math.min(innerW,innerH)*0.22);
  const mid=Math.round(Math.min(innerW,innerH)*0.13);

  ctx.font=`900 ${big}px Arial`;
  ctx.fillText("V", xL, yTop);
  ctx.fillText("M", xR, yTop);

  ctx.font=`900 ${mid}px Arial`;
  ctx.fillText("Valentine", (innerMinX+innerMaxX)/2, yBottom);

  const data=ctx.getImageData(0,0,w,h).data;

  textPoints=[];
  for(let y=0;y<h;y+=5){
    for(let x=0;x<w;x+=5){
      const i=(y*w+x)*4;
      if(data[i+3]>150 && pointInsideHeart(x,y)){
        textPoints.push({x,y});
      }
    }
  }

  shuffle(textPoints);

  targets=[];
  const count=Math.min(hearts.length,textPoints.length);
  for(let i=0;i<count;i++) targets[i]=textPoints[i];
}

// ---------------- RENDER ----------------

Events.on(render,"afterRender",()=>{
  const ctx=render.context;

  // контур серця
  ctx.beginPath();
  ctx.moveTo(outline[0].x, outline[0].y);
  for(const p of outline) ctx.lineTo(p.x,p.y);
  ctx.closePath();

  const grad=ctx.createLinearGradient(0,0,w,h);
  grad.addColorStop(0,"#ff6aa2");
  grad.addColorStop(1,"#ff003c");

  ctx.strokeStyle=grad;
  ctx.lineWidth=6;
  ctx.shadowBlur=25;
  ctx.shadowColor="#ff3d7a";
  ctx.stroke();
  ctx.shadowBlur=0;

  // частинки
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  for(const hrt of hearts){
    const p=hrt.body.position;
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(hrt.body.angle);
    ctx.font=(hrt.r*2)+"px system-ui, Apple Color Emoji";
    ctx.fillText("❤️",0,0);
    ctx.restore();
  }
});

// ---------------- MOTION CONTROL ----------------

// 1) deviceorientation: стабільніше за devicemotion для “нахилу”
function onOrientation(e){
  if(textMode) return;

  // beta: front-back, gamma: left-right
  const beta = (e.beta ?? 0);
  const gamma = (e.gamma ?? 0);

  // мапінг у гравітацію
  const gx = Math.max(-1, Math.min(1, gamma / 30));
  const gy = Math.max(-1, Math.min(1, beta / 30));

  engine.gravity.x = gx;
  engine.gravity.y = gy;
}

// 2) fallback: тягнемо гравітацію до курсора/тачу
function onPointerMove(ev){
  if(textMode) return;
  const rect = stage.getBoundingClientRect();
  const x = (ev.clientX - rect.left) / rect.width;
  const y = (ev.clientY - rect.top) / rect.height;
  engine.gravity.x = (x - 0.5) * 2;
  engine.gravity.y = (y - 0.5) * 2;
}

// iOS просить permission
async function enableMotion(){
  if (typeof DeviceOrientationEvent !== "undefined" &&
      typeof DeviceOrientationEvent.requestPermission === "function") {
    try{
      const res = await DeviceOrientationEvent.requestPermission();
      if(res === "granted"){
        window.addEventListener("deviceorientation", onOrientation, true);
      }
    }catch(_){}
  } else {
    window.addEventListener("deviceorientation", onOrientation, true);
  }
}

window.addEventListener("pointerdown", async (e)=>{
  await enableMotion();
  // якщо орієнтації нема, то буде працювати pointer move
  stage.setPointerCapture?.(e.pointerId);
  stage.addEventListener("pointermove", onPointerMove);
},{once:true});

window.addEventListener("keydown",e=>{
  if(e.code==="Space"){
    for(let i=0;i<25;i++) spawn();
  }
});

// старт
for(let i=0;i<60;i++) spawn();
</script>
</body>
</html>
