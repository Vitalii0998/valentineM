<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Heart Physics</title>

<style>
html,body{
  margin:0;
  height:100%;
  background:radial-gradient(circle at 50% 40%, #1b2040 0%, #0d1025 70%);
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
}
#stage{
  width:98vmin;
  height:98vmin;
}
canvas{width:100%;height:100%}
</style>
</head>
<body>
<div id="stage"></div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
const {Engine,Render,Runner,Bodies,Composite,Body,Events} = Matter;

const stage=document.getElementById("stage");
const engine=Engine.create();
engine.positionIterations=10;
engine.velocityIterations=10;
engine.enableSleeping=false;

const w=stage.clientWidth;
const h=stage.clientHeight;
const DPR=Math.min(window.devicePixelRatio||1,3);

const render=Render.create({
  element:stage,
  engine,
  options:{
    width:w,
    height:h,
    wireframes:false,
    background:"transparent",
    pixelRatio:DPR
  }
});

Render.run(render);
Runner.run(Runner.create(),engine);

// ---------------- HEART SHAPE ----------------

function heartPoints(cx,cy,scale,n=220){
  const pts=[];
  for(let i=0;i<n;i++){
    const t=(i/n)*Math.PI*2;
    const x=16*Math.pow(Math.sin(t),3);
    const y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
    pts.push({x:cx+x*scale,y:cy-y*scale});
  }
  return pts;
}

const centerX=w/2;
const centerY=h/2;
const scale=Math.min(w,h)*0.03;

function pointInsideHeart(x,y){
  // Формула серця нормалізована в діапазоні ~[-1..1],
  // а наш контур будується параметрично з множником 16*scale.
  // Тому перевірку "всередині" треба масштабувати так само,
  // інакше майже всі точки вважались "зовні" та злипались у центрі.
  const norm=16*scale;
  const dx=(x-centerX)/norm;
  const dy=(centerY-y)/norm;
  return Math.pow(dx*dx+dy*dy-1,3)-dx*dx*dy*dy*dy <= 0;
}

const pts=heartPoints(centerX,centerY,scale);

// фізичні стінки
for(let i=0;i<pts.length;i++){
  const a=pts[i];
  const b=pts[(i+1)%pts.length];
  const dx=b.x-a.x;
  const dy=b.y-a.y;
  const len=Math.hypot(dx,dy);
  const angle=Math.atan2(dy,dx);

  const wall=Bodies.rectangle(
    (a.x+b.x)/2,
    (a.y+b.y)/2,
    len+25,
    25,
    {
      isStatic:true,
      friction:0,
      frictionStatic:0,
      restitution:0.2,
      collisionFilter:{ category:0x0001 }
    }
  );

  Body.setAngle(wall,angle);
  Composite.add(engine.world,wall);
}

// ---------------- PARTICLES ----------------

const hearts=[];
let textMode=false;
let textPoints=[];
let targets=[];
let resetMode="idle"; // idle | gather | explode
let resetGatherStartedAt=0;

const NORMAL_HEART_RADIUS=5.6;
const TEXT_MODE_TRIGGER=1200;
const MAX_HEARTS=3200;
const SHAKE_SPAWN_BURST=34;
const KEYBOARD_SPAWN_BURST=28;

const heartSpriteCache=new Map();
function getHeartSprite(size){
  const key=Math.max(3,Math.round(size));
  if(heartSpriteCache.has(key)) return heartSpriteCache.get(key);
  const c=document.createElement("canvas");
  const pad=4;
  c.width=key+pad*2;
  c.height=key+pad*2;
  const cctx=c.getContext("2d");
  const cx=c.width/2;
  const cy=c.height/2+0.2;
  const s=key/18;

  cctx.beginPath();
  cctx.moveTo(cx,cy+7*s);
  cctx.bezierCurveTo(cx-8*s,cy+1*s,cx-8*s,cy-4*s,cx,cy-1*s);
  cctx.bezierCurveTo(cx+8*s,cy-4*s,cx+8*s,cy+1*s,cx,cy+7*s);
  cctx.closePath();

  cctx.fillStyle="#ff295f";
  cctx.fill();
  cctx.lineWidth=Math.max(0.8,1.2*s);
  cctx.strokeStyle="rgba(255,255,255,0.45)";
  cctx.stroke();

  heartSpriteCache.set(key,c);
  return c;
}

function randomInside(){
  let x,y;
  do{
    x=centerX+(Math.random()-0.5)*scale*18;
    y=centerY+(Math.random()-0.5)*scale*18;
  }while(!pointInsideHeart(x,y));
  return {x,y};
}

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=(Math.random()*(i+1))|0;
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}

function enterTextMode(){
  if(resetMode!=="idle") return;
  textMode=true;
  generateTextPoints();

  // вимикаємо колізії і гравітацію для стабільного формування тексту
  engine.gravity.x=0;
  engine.gravity.y=0;

  for(const h of hearts){
    Body.setStatic(h.body,false);

    // не колайдиться з іншими частинками і взагалі ні з чим (включно зі стінками)
    h.body.collisionFilter.group = -1;
    h.body.collisionFilter.mask = 0;

    Body.setVelocity(h.body,{x:0,y:0});
    Body.setAngularVelocity(h.body,0);

    h.targetDrawScale=0.18;
  }
}

function startResetSequence(){
  if(!textMode || resetMode!=="idle") return;

  resetMode="gather";
  resetGatherStartedAt=performance.now();
  textMode=false;
  targets.length=0;

  engine.gravity.x=0;
  engine.gravity.y=0;

  for(const h of hearts){
    Body.setStatic(h.body,false);
    h.body.collisionFilter.group=-1;
    h.body.collisionFilter.mask=0;
    Body.setVelocity(h.body,{x:0,y:0});
    Body.setAngularVelocity(h.body,0);
    h.targetDrawScale=0.26;
  }
}

function triggerExplosion(){
  resetMode="explode";

  engine.gravity.x=0;
  engine.gravity.y=1;

  for(const h of hearts){
    const p=h.body.position;
    const dx=p.x-centerX;
    const dy=p.y-centerY;
    const len=Math.hypot(dx,dy)||1;
    const ux=dx/len;
    const uy=dy/len;
    const speed=8+Math.random()*5;

    Body.setStatic(h.body,false);
    h.body.collisionFilter.group=0;
    h.body.collisionFilter.mask=0x0001;
    Body.setVelocity(h.body,{x:ux*speed,y:uy*speed*0.85-1.6});
    Body.setAngularVelocity(h.body,(Math.random()-0.5)*0.55);
    h.targetDrawScale=0.5;
  }
}

function cleanupExplodedHearts(){
  for(let i=hearts.length-1;i>=0;i--){
    const hb=hearts[i].body;
    const p=hb.position;
    if((p.y>h+80 && hb.velocity.y>0.1) || p.x<-80 || p.x>w+80){
      Composite.remove(engine.world,hb);
      hearts.splice(i,1);
    }
  }

  if(hearts.length===0){
    resetMode="idle";
    textMode=false;
    textPoints=[];
    targets=[];
    engine.gravity.x=0;
    engine.gravity.y=0;
  }
}

function spawn(){
  if(textMode) return; // важливо: не додаємо нові частинки в режимі тексту

  const r = NORMAL_HEART_RADIUS;
  const pos = randomInside();

  const body = Bodies.circle(pos.x,pos.y,r,{
    restitution:0.05,
    friction:0.03,
    frictionStatic:0,
    frictionAir:0.0006,
    density:0.003,
    render:{visible:false}
  });

  Composite.add(engine.world,body);
  hearts.push({body,r,drawScale:1,targetDrawScale:1});

  if(hearts.length>TEXT_MODE_TRIGGER && !textMode){
    enterTextMode();
  }

  if(hearts.length>MAX_HEARTS){
    Composite.remove(engine.world,hearts.shift().body);
  }
}

// ---------------- TEXT ----------------

function generateTextPoints(){
  const off=document.createElement("canvas");
  off.width=w;
  off.height=h;
  const ctx=off.getContext("2d");

  const step=2;

  function collectTextPoints(text,font,x,y){
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle="white";
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.font=font;
    ctx.fillText(text,x,y);

    const data=ctx.getImageData(0,0,w,h).data;
    const points=[];
    for(let py=0;py<h;py+=step){
      for(let px=0;px<w;px+=step){
        const i=(py*w+px)*4;
        if(data[i+3]>150 && pointInsideHeart(px,py)){
          points.push({x:px,y:py});
        }
      }
    }
    return shuffle(points);
  }

  function sampleLine(x1,y1,x2,y2,n){
    const pts=[];
    for(let i=0;i<n;i++){
      const t=n===1?0:i/(n-1);
      const x=x1+(x2-x1)*t;
      const y=y1+(y2-y1)*t;
      if(pointInsideHeart(x,y)) pts.push({x,y});
    }
    return pts;
  }

  function buildVPoints(cx,cy,size){
    return [
      ...sampleLine(cx-size,cy-size*0.7,cx,cy+size,50),
      ...sampleLine(cx+size,cy-size*0.7,cx,cy+size,50)
    ];
  }

  function buildMPoints(cx,cy,size){
    return [
      ...sampleLine(cx-size,cy+size,cx-size,cy-size,42),
      ...sampleLine(cx-size,cy-size,cx,cy+size*0.1,34),
      ...sampleLine(cx,cy+size*0.1,cx+size,cy-size,34),
      ...sampleLine(cx+size,cy-size,cx+size,cy+size,42)
    ];
  }

  function ensurePool(pool,fallbackFactory){
    const dedup=[];
    const used=new Set();
    for(const p of pool){
      const k=((p.x|0)<<16)|(p.y|0);
      if(!used.has(k)){
        used.add(k);
        dedup.push(p);
      }
    }
    if(dedup.length>=24) return dedup;
    return fallbackFactory();
  }

  function assignFromPool(pool,count,jitterMax=4,drawScale=0.18){
    const out=[];
    if(pool.length===0){
      for(let i=0;i<count;i++) out.push({...randomInside(),drawScale});
      return out;
    }
    for(let i=0;i<count;i++){
      const base=pool[i%pool.length];
      const rep=(i/pool.length)|0;
      if(rep===0){
        out.push({x:base.x,y:base.y,drawScale});
        continue;
      }
      const angle=i*0.63+rep*1.17;
      const radius=Math.min(jitterMax,rep*0.45);
      const x=base.x+Math.cos(angle)*radius;
      const y=base.y+Math.sin(angle)*radius;
      out.push(pointInsideHeart(x,y)?{x,y,drawScale}:{x:base.x,y:base.y,drawScale});
    }
    return out;
  }

  // Розкладка: V ліворуч, M праворуч, знизу "valentine's" і під ним по центру "day"
  const xL=centerX-scale*4.8;
  const xR=centerX+scale*4.8;
  const yTop=centerY-scale*1.5;
  const yWordTop=centerY+scale*4.2;
  const yWordBottom=yWordTop+scale*2.2;

  const fontVM=`900 ${Math.round(scale*4.2)}px Arial`;
  const fontWordTop=`900 ${Math.round(scale*2.45)}px Arial`;
  const fontWordBottom=`900 ${Math.round(scale*2.45)}px Arial`;

  const vGlyph=collectTextPoints("V",fontVM,xL,yTop);
  const mGlyph=collectTextPoints("M",fontVM,xR,yTop);
  const wordTopGlyph=collectTextPoints("valentine's",fontWordTop,centerX,yWordTop);
  const wordBottomGlyph=collectTextPoints("day",fontWordBottom,centerX,yWordBottom);

  const vPoints=ensurePool(vGlyph,()=>buildVPoints(xL,yTop,scale*1.55));
  const mPoints=ensurePool(mGlyph,()=>buildMPoints(xR,yTop,scale*1.45));
  const wordTopPoints=wordTopGlyph.length>=28
    ? wordTopGlyph
    : sampleLine(centerX-scale*5.2,yWordTop,centerX+scale*5.2,yWordTop,210);
  const wordBottomPoints=wordBottomGlyph.length>=14
    ? wordBottomGlyph
    : sampleLine(centerX-scale*1.8,yWordBottom,centerX+scale*1.8,yWordBottom,90);
  const wordPoints=[...wordTopPoints,...wordBottomPoints];

  textPoints=[...vPoints,...mPoints,...wordPoints];

  targets=[];
  if(textPoints.length===0){
    for(let i=0;i<hearts.length;i++) targets[i]={...randomInside(),drawScale:0.18};
    return;
  }

  // Трохи більше сердечок у V/M, але більшість лишається на words
  const total=hearts.length;
  const vCount=Math.round(total*0.16);
  const mCount=Math.round(total*0.24);
  const wordCount=total-vCount-mCount;

  targets.push(...assignFromPool(vPoints,vCount,3.1,0.19));
  targets.push(...assignFromPool(mPoints,mCount,3.1,0.19));

  const wordTopCount=Math.round(wordCount*0.58);
  const wordBottomCount=wordCount-wordTopCount;
  targets.push(...assignFromPool(wordTopPoints,wordTopCount,0.10,0.085));
  targets.push(...assignFromPool(wordBottomPoints,wordBottomCount,0.08,0.075));

  shuffle(targets);
}


// ---------------- RENDER ----------------

Events.on(render,"afterRender",()=>{
  const ctx=render.context;

  // контур серця
  ctx.beginPath();
  ctx.moveTo(pts[0].x,pts[0].y);
  for(const p of pts) ctx.lineTo(p.x,p.y);
  ctx.closePath();

  const grad=ctx.createLinearGradient(0,0,w,h);
  grad.addColorStop(0,"#ff6aa2");
  grad.addColorStop(1,"#ff003c");

  ctx.strokeStyle=grad;
  ctx.lineWidth=6;
  ctx.shadowBlur=25;
  ctx.shadowColor="#ff3d7a";
  ctx.stroke();
  ctx.shadowBlur=0;

  // частинки
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  for(const hrt of hearts){
    const p=hrt.body.position;
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(hrt.body.angle);
    hrt.drawScale += (hrt.targetDrawScale-hrt.drawScale)*0.16;
    const glyphSize=Math.max(2.6,hrt.r*2*hrt.drawScale);
    const sprite=getHeartSprite(glyphSize);
    ctx.drawImage(sprite,-sprite.width/2,-sprite.height/2);
    ctx.restore();
  }
});

// ---------------- MOTION ----------------

let lastShake=0;

function updateTextMode(){
  if(resetMode==="gather"){
    let settled=0;
    for(const h of hearts){
      const px=h.body.position.x;
      const py=h.body.position.y;
      const nx=px+(centerX-px)*0.22;
      const ny=py+(centerY-py)*0.22;
      Body.setPosition(h.body,{x:nx,y:ny});
      Body.setVelocity(h.body,{x:0,y:0});
      Body.setAngularVelocity(h.body,0);
      h.targetDrawScale=0.22;

      const dx=centerX-nx;
      const dy=centerY-ny;
      if(dx*dx+dy*dy<18*18) settled++;
    }

    if(settled>=Math.max(1,Math.floor(hearts.length*0.88)) || performance.now()-resetGatherStartedAt>700){
      triggerExplosion();
    }
    return;
  }

  if(resetMode==="explode"){
    cleanupExplodedHearts();
    return;
  }

  if(!textMode) return;

  // плавно підтягувати до цілей, без залежності від devicemotion
  for(let i=0;i<hearts.length;i++){
    const h=hearts[i];
    if(h.body.isStatic) continue;
    const t=targets[i];
    if(!t) continue;

    const px=h.body.position.x;
    const py=h.body.position.y;

    const lerp=(t.drawScale ?? 0.18) < 0.1 ? 0.24 : 0.18;
    const nx=px+(t.x-px)*lerp;
    const ny=py+(t.y-py)*lerp;

    Body.setPosition(h.body,{x:nx,y:ny});
    Body.setVelocity(h.body,{x:0,y:0});
    Body.setAngularVelocity(h.body,0);

    h.targetDrawScale=t.drawScale ?? 0.18;

    const dx=t.x-nx;
    const dy=t.y-ny;
    const settleDist=(t.drawScale ?? 0.18) < 0.1 ? 3.2 : 2.5;
    if(dx*dx+dy*dy < settleDist*settleDist){
      Body.setPosition(h.body,{x:t.x,y:t.y});
      Body.setVelocity(h.body,{x:0,y:0});
      Body.setStatic(h.body,true);
    }
  }
}

Events.on(engine,"beforeUpdate",updateTextMode);

function motion(e){
  if(textMode) return;

  // NORMAL MODE
  const now=Date.now();

  const a=e.acceleration||e.accelerationIncludingGravity;
  if(a){
    const mag=Math.sqrt((a.x||0)**2+(a.y||0)**2+(a.z||0)**2);
    if(mag>12 && now-lastShake>140){
      lastShake=now;
      for(let i=0;i<SHAKE_SPAWN_BURST;i++) spawn();
    }
  }

  const g=e.accelerationIncludingGravity;
  if(g){
    engine.gravity.x=-(g.x||0)/10;
    engine.gravity.y=(g.y||0)/10;
  }
}

window.addEventListener("pointerdown",()=>{
  if(!window.__motionBound){
    window.addEventListener("devicemotion",motion,{passive:true});
    window.__motionBound=true;
  }
  startResetSequence();
});

window.addEventListener("keydown",e=>{
  if(e.code==="Space"){
    for(let i=0;i<KEYBOARD_SPAWN_BURST;i++) spawn();
  }
});

</script>
</body>
</html>
